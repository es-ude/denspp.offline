from dataclasses import dataclass
import numpy as np
import pandas as pd
import impedancefitter as ifit
from copy import deepcopy
from os import mkdir, getcwd
from os.path import join, exists
from datetime import datetime
from fractions import Fraction
from platform import system

from package.yaml_handler import yaml_config_handler
from package.structure_builder import create_folder_general_firstrun
from package.data_process.transformation import do_fft_withimag
from package.stim.imp_fitting.plot_impfit import (plot_transient, plot_transient_fft, plot_impedance)


def _quantize_transient_signal(transient_orig: dict, fs_new: float, u_lsb: float, i_gain=2e3) -> dict:
    """Performing a re-quantization of the transient input signal (amplitude and time)
    Args:
        transient_orig:     Input dictionary with transient signal ['V': voltage, 'I': current, 'fs': sampling rate]
        fs_new:             New sampling rate
        u_lsb:              New smallest voltage resolution (least significant bit, LSB)
    Returns:
        Dictionary with new transient output ['V': voltage, 'I': current, 'fs': sampling rate]
    """
    current0 = __do_resample_time(transient_orig['I'], transient_orig['fs'], fs_new, do_offset_comp=True)
    voltage0 = __do_resample_time(transient_orig['V'], transient_orig['fs'], fs_new)

    current_tran = __do_resample_amplitude(i_gain * current0, u_lsb) / i_gain
    voltage_tran = __do_resample_amplitude(voltage0, u_lsb)
    return {'I': current_tran, 'V': voltage_tran, 'fs': fs_new}


def __do_resample_time(signal_in: np.ndarray, fs_orig: float, fs_new: float,
                       do_offset_comp=False) -> np.ndarray:
    """Do resampling of time value from transient signals
    Args:
        signal_in:      Numpy array of transient input signal
        fs_orig:        Original sampling rate value
        fs_new:         New sampling rate value
        do_offset_comp: Do offset compensation on output
    Returns:
        Numpy array of resampled into
    """
    from scipy.signal import resample_poly

    u_chck = np.mean(signal_in)
    u_off = u_chck if not do_offset_comp else 0
    if not fs_orig == fs_new:
        p, q = Fraction(fs_new / fs_orig).limit_denominator(10000).as_integer_ratio()
        return u_off + resample_poly(signal_in - u_chck, p, q)
    else:
        return signal_in - u_off


def __do_resample_amplitude(signal_in: np.ndarray, u_lsb: float) -> np.ndarray:
    """Do resampling of amplitude from transient signal
    Args:
        signal_in:  Numpy array with transient signal
        u_lsb:      New smallest voltage resolution (least significant bit, LSB)
    Returns:
        Numpy array with re-sampled input (amplitude)
    """
    return u_lsb * np.round(signal_in / u_lsb, 0) if not u_lsb == 0.0 else signal_in


def load_params_from_csv(path2model: str) -> dict:
    """Loading the parameters from csv file (generated by impedance fitter)"""
    params = pd.read_csv(path2model).to_dict(orient="records")[0]
    return params


def _fix_param_values(params: dict, params_fix: dict) -> dict:
    """Fixation of key value in params"""
    params_new = deepcopy(params)
    for key in params_fix.keys():
        params_new[key]["vary"] = False
        params_new[key]["value"] = params_fix[key]
    return params_new


def _transfer_detail_to_params(params2dict: dict) -> dict:
    """Transfer detailed parameter dict in light dict"""
    params = dict()
    for p in params2dict:
        params[p] = params2dict[p]["value"]
    return params


def _transfer_params_to_detail(params: dict) -> dict:
    """Transfer light parameter dict in detailed dict"""
    params2dict = {}
    for p in params:
        params2dict[p] = {}
        params2dict[p]["value"] = params[p]
    return params2dict


def find_stimlation_waveform_position(signals: dict, split_on_voltage=False) -> dict:
    """Find the positions in which a transient stimulation waveform is available
    Args:
        signals:            Dictionary with stimulation signals ['V': voltage, 'I': current]
        split_on_voltage:   Boolean for making single stimulation trails on voltage [True] or current [False]
    Returns:
        Dictionary with position of stimulation phases from input transient stimulation waveform
    """
    # --- Internal function
    def find_start_stopp_position(list_positions: np.ndarray, condition, type: int) -> [list, list]:
        """Find all positions of start and stop of continous signal"""
        if type == 0:
            xpos_all = np.argwhere(list_positions == condition).flatten()
        elif type == 1:
            xpos_all = np.argwhere(list_positions >= condition).flatten()
        else:
            xpos_all = np.argwhere(list_positions <= condition).flatten()

        xpos_pos = np.argwhere(np.diff(xpos_all) > 1).flatten()
        xpos_start = [pos for pos in xpos_all[xpos_pos + 1]]
        xpos_start.insert(0, xpos_all[0])
        xpos_stopp = [pos for pos in xpos_all[xpos_pos]]
        xpos_stopp.append(xpos_all[-1])
        return xpos_start, xpos_stopp

    # --- Preparing signals
    input_signal_nml = signals['V'] if split_on_voltage else signals['I']
    input_signal_abs = np.abs(input_signal_nml)

    # --- Determining positions of absolute signal incl. state
    xpos_stim_start, xpos_stim_stopp = find_start_stopp_position(input_signal_abs, 0.6 * input_signal_abs.max(), 1)
    state_cathodic = np.zeros((len(xpos_stim_start), ), dtype=bool)
    for idx in range(len(xpos_stim_start)):
        signal_mean = np.mean(input_signal_nml[xpos_stim_start[idx]:xpos_stim_stopp[idx]])
        state_cathodic[idx] = np.sign(signal_mean) == -1.0
    del signal_mean, idx
    
    # --- Determining overall stimulation pattern
    xpos_ano_start, xpos_ano_stopp = find_start_stopp_position(state_cathodic, False, 0)
    xpos_cat_start, xpos_cat_stopp = find_start_stopp_position(state_cathodic, True, 1)

    is_cathodic_first = xpos_ano_start[0] > xpos_cat_start[0]
    xpos_cat_phase = [[xpos_stim_start[xpos_cat_start[idx]]-10, xpos_stim_stopp[xpos_cat_stopp[idx]]+10] for idx in range(len(xpos_cat_start))]
    xpos_ano_phase = [[xpos_stim_start[xpos_ano_start[idx]]-10, xpos_stim_stopp[xpos_ano_stopp[idx]]+10] for idx in range(len(xpos_ano_start))]

    # --- Splitting signals
    run_dict_positions = {'cathodic_first': is_cathodic_first,
                          'xpos_cat': xpos_cat_phase,
                          'xpos_ano': xpos_ano_phase}
    return run_dict_positions


def splitting_stimulation_waveforms_into_single_trials(signals_input: dict,
                                                       split_on_voltage=False, do_offset_comp=False) -> dict:
    """
    Args:
        signals_input:      Dictionary with stimulation signals ['V': voltage, 'I': current]
        positions:          Dictionary from
        split_on_voltage:   Boolean for making single stimulation trails on voltage [True] or current [False]
        do_offset_comp:     Do offset compensation [Default: False]
    Returns:
        Dictionary with position of stimulation phases from input transient stimulation waveform
    """
    # --- Getting positions of stimulation phase
    phase_positions = find_stimlation_waveform_position(signals_input, split_on_voltage)

    # --- Preparing signals
    input_signal_nml = signals_input['V'] if split_on_voltage else signals_input['I']
    is_cathodic_first = phase_positions['cathodic_first']
    xpos_cat_phase = phase_positions['xpos_cat']
    xpos_ano_phase = phase_positions['xpos_ano']

    # --- Offset compensation
    mean_value = np.mean(input_signal_nml[0:int(0.8 * xpos_cat_phase[0][0])] if is_cathodic_first else input_signal_nml[0:xpos_ano_phase[0][0]-10])
    input_signal_nml -= mean_value if do_offset_comp else 0

    # --- Splitting signals
    positions_old = 0
    voltage_separated = list()
    current_separated = list()
    for pos_cat, pos_ano in zip(xpos_cat_phase, xpos_ano_phase):
        positions_delta = (pos_cat[0] if is_cathodic_first else pos_ano[0]) - positions_old
        position_start = (pos_cat[0] if is_cathodic_first else pos_ano[0]) - int(0.5 * positions_delta)
        position_stopp = pos_ano[1] if is_cathodic_first else pos_cat[1] + int(0.5 * positions_delta)
        positions_old = (pos_ano[1] if is_cathodic_first else pos_cat[1])

        voltage_separated.append(signals_input['V'][position_start:position_stopp])
        current_separated.append(signals_input['I'][position_start:position_stopp])

    # --- Translating information into dictionary
    signals_separated = dict()
    for key, data in signals_input.items():
        if key == 'V':
            signals_separated.update({key: voltage_separated})
        elif key == 'I':
            signals_separated.update({key: current_separated})
        else:
            signals_separated.update({key: data})
    return signals_separated


@dataclass(frozen=True)
class Settings_ImpFit:
    """Configuration class for handling the impedance fitting processing pipeline"""
    model:      str
    path2fits:  str
    path2tran:  str


RecommendedSettingsImpFit = Settings_ImpFit(
    model="R_tis + W_war + parallel(R_ct, C_dl)",
    path2fits='../../2_Data/00_ImpedanceFitter',
    path2tran='C:/HomeOffice/Austausch_Rostock/TransienteMessungen/180522_Messung/1_Messdaten'
)


class ImpFit_Handler:
    fit_model = 'R_tis'
    _path2save: str
    _path2figure: str
    _path2impfit: str
    _path2params: str
    _params_default = {}
    _index_impedance_result = '_impedance.csv'
    _index_params_result = '_params.csv'

    def __init__(self, path2start='', generate_folders=True):
        """Class of Impedance Fitter from transient electrical stimulation signals
        More documentation on: https://impedancefitter.readthedocs.io/en/latest/index.html
        Args:
            path2start: Definition of path who the processing results will be stored [if not '' given folder is used]
            generate_folders: Generation of dummy folder structure
        """
        create_folder_general_firstrun()
        self.__create_folders_impedance(path2start, generate_folders)

        self.__trennzeichen = '\\' if system() == 'Windows' else '/'
        self.take_freq_range = [1e2, 1e5]
        self.__results = dict()

    def __create_folders_impedance(self, folder_start='', generate_folder=True) -> None:
        """Creating empty folder structure if impedance fitting is done from transient signal"""
        # --- Finding the start folder
        folder2search = '3_Python'
        folder_run_name = f'{datetime.now().strftime("%Y%m%d_%H%M%S")}_imp_fit' if not folder_start else folder_start

        # --- Definition of folder structure
        self._path2save = join(getcwd().split(folder2search)[0], folder2search, 'runs', folder_run_name)
        self._path2figure = join(self._path2save, 'figure')
        self._path2impfit = join(self._path2save, 'impedance')
        self._path2params = join(self._path2save, 'model_param')

        # --- Generating the folders
        if generate_folder:
            list_folders = [self._path2save, self._path2figure, self._path2impfit, self._path2params]
            for folder_name in list_folders:
                if not exists(folder_name):
                    mkdir(folder_name)

    def load_fitmodel(self, model: str) -> None:
        """Loading the fitting model"""
        self.fit_model = model

    def get_results(self) -> dict:
        """Getting the results from impedance fitting"""
        return self.__results

    def get_path2save(self) -> str:
        """Getting the path where data is stored"""
        return self._path2save

    def get_params_default(self) -> dict:
        """Getting the default parameters for fitting impedance values to model"""
        return _transfer_detail_to_params(self._params_default)

    def load_params_default(self, path2model: str, fix_value=None) -> dict:
        """Loading parameter list from electrode simulation as default (like initial simulation with NGsolve)"""
        params = load_params_from_csv(path2model)
        params2dict = _transfer_params_to_detail(params)
        params2dict = _fix_param_values(params2dict, fix_value)
        self._params_default = params2dict
        return params2dict

    def define_params_default(self, params: dict) -> None:
        """Defining an initial parameter list"""
        self._params_default = _transfer_params_to_detail(params)

    def save_impedance_to_csv(self, file_name: str, data: dict) -> None:
        """Saving fitted impedance results from transient analysis into csv"""
        name = file_name.split(self.__trennzeichen)[-1]
        path2file = join(self._path2impfit, f'{name.split(".")[0]}{self._index_impedance_result}')

        df = pd.DataFrame(data)
        df.to_csv(path2file, index=False)

    def fit_impedance_to_model(self, file_name: str, do_print_report=False, save_results=True) -> dict:
        """Fitting extracted impedance fit values to model for getting model parameter
        Args:
            file_name:          File name of the impedance file
            do_print_report:    Printing the fit results into terminal
            save_results:       Saving the fit results into csv file
        Returns:
            Dictionary with fitted parameters to corresponding model
        """
        if not file_name.split('.')[-1] == 'csv':
            file_imp = file_name.split(self.__trennzeichen)[-1].split('.')[0]
            file_list = [f'{file_imp}{self._index_impedance_result}']
            folder_src = self._path2impfit
        else:
            used_separation = '/' if '/' in file_name else '\\'
            file_list = [file_name.split(used_separation)[-1]]
            folder_src = file_name[:-len(file_list[0])-1]

        fitter = ifit.Fitter("CSV", fileList=file_list, directory=folder_src, LogLevel='WARNING')
        if not len(self._params_default) == 0:
            fitter.run(self.fit_model, parameters=self._params_default, weighting="modulus", report=do_print_report)
        else:
            fitter.run(self.fit_model, weighting="modulus", report=do_print_report)
        model_params = fitter.fit_data[f'{file_list[0]}_0']

        # --- Saving results
        if save_results:
            filename_csv = file_name.split(self.__trennzeichen)[-1].split(".")[0]
            path2file = join(self._path2params, f'{filename_csv}{self._index_params_result}')
            df = pd.DataFrame(model_params, index=[0])
            df.to_csv(path2file, index=False)
        return model_params

    def __transform_transient_signal(self, transient_used: dict, ratio_amp=10.0) -> [dict, dict]:
        """Transforming the transient input signal
        Args:
            transient_used: Dictionary with transient signal ['V': voltage, 'I': current, 'fs': sampling rate]
            ratio_amp:      Given value for amplitude ratio for reducing data in spectrum
        Returns:
            Two dictionaries with spectrum-transformed input signal ['freq', 'V', 'I', 'Z'] and used values for fitting
        """
        current_fft = do_fft_withimag(transient_used['I'], transient_used['fs'])[1]
        freq, voltage_fft = do_fft_withimag(transient_used['V'], transient_used['fs'])

        # Break condition: Only looking on interesting signal parts (signal peaks)
        idx = np.nonzero(np.invert(np.isclose(np.abs(current_fft), 0, atol=np.max(np.abs(current_fft)) / ratio_amp)))
        if len(idx[0]) == 0:
            return {}, {}
        else:
            imp_measured = voltage_fft / current_fft
            df = freq[1] - freq[0]
            startidx = np.where(idx[0] >= int(self.take_freq_range[0] / df))[0]
            cutidx = np.where(idx[0] >= int(self.take_freq_range[1] / df))[0]
            if len(cutidx) == 0:
                cutidx = idx[0][-1]
            else:
                cutidx = cutidx[0]

            if len(startidx) == 0:
                startidx = idx[0][0]
            else:
                startidx = startidx[0]
            idxcut = idx[0][startidx:cutidx]

            return ({'freq': freq, 'V': voltage_fft, 'I': current_fft, 'Z': imp_measured},
                    {'freq': freq[idxcut], 'real': imp_measured[idxcut].real, 'imag': imp_measured[idxcut].imag})

    def calculate_impedance_from_transient_dict(
            self, transient_signal: dict, file_name: str,
            ratio_amp=10.0, fs_new=0.0, u_lsb=0.0,
            create_plot=False, show_plot=False) -> bool:
        """Calculating the impedance values from transient input (using dict format)
        Args:
            transient_signal:   Dictionary with transient input ['fs': sampling rate, 'V': voltage, 'I': current]
            file_name:          Used file name from which the transient data is extracted
            ratio_amp:          Given value for amplitude ratio for reducing data in spectrum
            fs_new:             New sampling rate [if 0.0 then re-quantization is ignored]
            u_lsb:              New LSB of transient signal [if 0.0 then re-quantization is ignored]
            create_plot:        Creating the plots from analysis
            show_plot:          Showing and blocking the plots
        Returns:
            Boolean value for breaking an external loop (data can be called with get_results())
        """
        fs_used = fs_new if not fs_new == 0.0 else transient_signal['fs']
        transient_quant = _quantize_transient_signal(transient_signal, fs_used, u_lsb)
        spectrum_signal, data_fit = self.__transform_transient_signal(
            transient_quant, ratio_amp=ratio_amp
        )

        self.__results = {'transient_signal': transient_quant, 'spectrum_signal': spectrum_signal}
        if create_plot:
            self.plot_transient_results(file_name, transient_quant, spectrum_signal, show_plot=show_plot)

        # --- Checking for breaking condition
        if len(data_fit) == 0:
            # Abort run due to non-activity
            return True
        else:
            # Saving impedance values and parameters to csv
            self.save_impedance_to_csv(file_name, data_fit)
            params = self.fit_impedance_to_model(file_name)
            self.__results.update({'params': params})
            return False

    def calculate_impedance_from_transient_numpy(
        self, voltage_signal: np.ndarray, current_signal: np.ndarray, fs_data: float, file_name: str,
        ratio_amp=10.0, fs_new=0.0, u_lsb=0.0,
        create_plot=False, show_plot=False
    ) -> bool:
        """Calculating the impedance values from transient input (using numpy format)
        Args:
            voltage_signal:     Numpy array with transient voltage signal
            current_signal:     Numpy array with transient current signal
            fs_data:            Sampling rate of transient input signal
            file_name:          Used file name from which the transient data is extracted
            ratio_amp:          Given value for amplitude ratio for reducing data in spectrum
            fs_new:             New sampling rate [if 0.0 then re-quantization is ignored]
            u_lsb:              New LSB of transient signal [if 0.0 then re-quantization is ignored]
            create_plot:        Creating the plots from analysis
            show_plot:          Showing and blocking the plots
        Returns:
            Boolean value for breaking an external loop (data can be called with get_results())
        """
        transient_signal = {'V': voltage_signal, 'I': current_signal, 'fs': fs_data}
        return self.calculate_impedance_from_transient_dict(
            transient_signal=transient_signal, file_name=file_name,
            ratio_amp=ratio_amp, fs_new=fs_new, u_lsb=u_lsb,
            create_plot=create_plot, show_plot=show_plot
        )

    def plot_transient_results(self, file_name: str, transient_signal: dict, spectrum_signal: dict,
                               show_plot=False) -> None:
        """Plotting the results of the transient input
        Args:
            file_name:          Used file name from which the transient data is extracted
            transient_signal:   Dictionary of used transient signal ['V': voltage, 'I': current, 'fs': sampling rate]
            spectrum_signal:    Dictionary of used spectrum signal ['V': voltage, 'I': current, 'freq': frequency]
            show_plot:          Showing and plotting the plot
        Returns:
              None
        """
        file0 = file_name.split(self.__trennzeichen)[-1].split('.')[0]
        plot_transient(transient_signal['fs'], transient_signal['V'], transient_signal['I'],
                       file_name=file0, path2save=self._path2figure, plot_charge=True)
        plot_transient_fft(spectrum_signal['freq'], spectrum_signal['V'], spectrum_signal['I'],
                           file_name=file0, path2save=self._path2figure)
        plot_impedance(spectrum_signal['freq'], imp_fit=spectrum_signal['Z'],
                       name=file0, path2save=self._path2figure, show_plot=show_plot)

    def __do_impedance_fitting(self, params: dict, freq: np.ndarray) -> dict:
        """Do impedance fitting with given parameters"""
        params2dict = _transfer_params_to_detail(params)
        fitter = ifit.Fitter("CSV", show=True, LogLevel='WARNING')
        fitter.run(self.fit_model, parameters=params2dict, report=False, show=True, weighting="modulus",
                   residual="absolute")

        ecm = ifit.get_equivalent_circuit_model(self.fit_model)
        imp_fit = ecm.eval(omega=2. * np.pi * freq, **params)
        return {'freq': freq, 'Z': imp_fit}

    def do_impedance_fit_from_params(self, params: dict, freq: np.ndarray) -> dict:
        """Extracting the impedance behaviour from predicted model parameters using impedancefitter, stored in csv file
        Args:
           params:  Dictionary with electrical model parameters
           freq:    Used frequency values for getting the impedance spectral signal
        Returns:
            Dictionary with 'freq' frequency and 'Z' spectral impedance value
        """
        return self.__do_impedance_fitting(params, freq)

    def do_impedance_fit_from_params_csv(self, path2params: str, freq: np.ndarray) -> dict:
        """Extracting the impedance behaviour from predicted model parameters using impedancefitter, stored in csv file
        Args:
           path2params:     Path to the extracted model parameters
           freq:            Used frequency values for getting the impedance spectral signal
        Returns:
            Dictionary with 'freq' frequency and 'Z' spectral impedance value
        """
        params = load_params_from_csv(path2params)
        return self.__do_impedance_fitting(params, freq)

    def do_impedance_fit_from_predicted_csv(self, path2imp: str, freq: np.ndarray) -> dict:
        """Extracting the impedance behaviour from predicted impedance values using impedancefitter, stored in csv file
        Args:
           path2imp:    Path to the extracted model parameters
           freq:        Used frequency values for getting the impedance spectral signal
        Returns:
            Dictionary with 'freq' frequency and 'Z' spectral impedance value
        """
        params = self.fit_impedance_to_model(path2imp, save_results=False)
        return self.__do_impedance_fitting(params, freq)

    def plot_impedance_results(self, imp_stim=None, imp_fit=None, imp_eis=None, imp_mod=None,
                               plot_name='', save_plot=False, show_plot=False) -> None:
        """Plotting the impedance results for different input modes
        Args:
            imp_stim:   Dictionary with impedance and frequency values from transient stimulation signal fitting
            imp_eis:    Dictionary with impedance and frequency values from electrical impedance spectroscopy
            imp_fit:    Dictionary with impedance and frequency values from electrical impedance spectroscopy (fit)
            imp_mod:    Dictionary with impedance and frequency values from NGsolve simulation
            plot_name:  Name of the plot for saving
            save_plot:  Saving plot
            show_plot:  Showing and plotting the results
        Returns:
            None
        """
        plot_impedance(imp_fit=imp_fit, imp_eis=imp_eis, imp_mod=imp_mod, imp_stim=imp_stim,
                       name=plot_name, path2save=self._path2figure if save_plot else '', show_plot=show_plot)


if __name__ == "__main__":
    # --- Settings
    yaml_config = yaml_config_handler(RecommendedSettingsImpFit, yaml_name="Config_ImpFit_Test")
    settings_impfit = yaml_config.get_class(Settings_ImpFit)

    path2imp = '../../../../2_Data/00_ImpedanceFitter'
    path2ngsolve = f'{path2imp}/impedance_expected_ngsolve.csv'
    path2test0 = f'{path2imp}/tek0000ALL_MATLAB_new_fit.csv'
    path2test1 = f'{path2imp}/tek0000ALL_MATLAB_impedance.csv'

    imp_handler = ImpFit_Handler()
    imp_handler.load_fitmodel(settings_impfit.model)
    imp_handler.load_params_default(path2ngsolve, {'ct_R': 8.33e6})

    # --- Step #1: Plotting impedance
    fit2freq = np.logspace(0, 6, 61, endpoint=True)
    z_prd = imp_handler.do_impedance_fit_from_params(imp_handler.get_params_default(), fit2freq)
    z_fit0 = imp_handler.do_impedance_fit_from_params_csv(path2test0, fit2freq)
    z_fit1 = imp_handler.do_impedance_fit_from_predicted_csv(path2test1, fit2freq)

    imp_handler.plot_impedance_results(imp_stim=z_fit0, imp_mod=z_prd, plot_name='comparison', show_plot=True)
